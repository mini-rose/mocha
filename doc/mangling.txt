FUNCTION MANGLING
-----------------

Each function name gets mangled in order to support overloading and generic
types, similar to what C++ or Rust does with their code.

	fn main() {}

The main function will get mangled to `cf.main`.

	add(i32 a, i64 b) -> cf.addil

This add function has 2 paramters, a regular int (i) and a 64 bit signed
integer (l), which get added at the end of the function name.

General construction:

	all symbols have the `cf` prefix
	|             a list of parameter types
	v             v
	cf.module.namexxx
	   ^      ^
	   |      the raw function name
	   each function name has the full module path


This means that `fn add<T>(T a, T b) {}` would get mangled differently
depending on the type of T. For example, add<i32>(...) would become
`addii`, while add<u128>(...) would become `addQQ`.

Plain data types get a single char as their type id. This is the full
table of plain data:

	+-------+----+
	| type  | id |
	+-------+----+
	| bool  | b  |
	| i8    | c  |
	| u8    | C  |
	| i16   | s  |
	| u16   | S  |
	| i32   | i  |
	| u32   | I  |
	| i64   | l  |
	| u64   | L  |
	| i128  | q  |
	| u128  | Q  |
	| str   | s  |
	+-------+----+

Note that the return type does not get mangled.
