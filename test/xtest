#!/usr/bin/python3
# Script for running & checking all tests.
from typing import Union
# Copyright (c) 2023 mini-rose

import subprocess
import shutil
import os

TEST_GROUPS = ["test/language"]


def collect_tests() -> list:
    tests = []

    for group in TEST_GROUPS:
        dirs = os.listdir(group)
        for dir in dirs:
            if not os.path.isdir(group + "/" + dir):
                continue
            tests.append(group + "." + dir)

    return sorted(tests)


class TestSettings:
    """Contains the test settings for a single test case. Provides default
    options for a test."""

    __name: str
    fields: dict

    def __init__(self, name: str):
        self.__name = name
        self.fields = {"fails": False, "flags": ""}

    @staticmethod
    def parse_value(value: str):
        if value == "true":
            return True, None
        if value == "false":
            return False
        else:
            return value

    def set_value(self, line: str):
        """Set a value of the settings. Takes a `key=value` line."""
        v = line.split("=", 1)
        if len(v) < 2:
            print(f"Invalid setting in {self.__name}: {line}")
            return

        k, v = v
        if k in self.fields:
            self.fields[k] = self.parse_value(v)
        else:
            print(f"Unknown setting in {self.__name}: `{k}`")


def parse_test_info(test_name: str, path: str) -> TestSettings:
    settings = TestSettings(test_name)
    path = path + "/test.info"

    if not os.path.exists(path):
        return settings
    with open(path) as f:
        lines = f.readlines()

    for line in lines:
        line = line.strip()
        if line.startswith("#"):
            continue
        settings.set_value(line)

    return settings


def run_test(test_name: str, out_dir: str) -> tuple[bool, Union[bytes, None]]:
    path = test_name.replace(".", "/")
    settings = parse_test_info(test_name, path)

    cmd = [os.path.abspath("xc/xc"), "--sysroot=" + os.path.abspath("lib"), "-o" + os.path.join(out_dir, "test"), "test.x"]
    if settings.fields["flags"]:
        cmd.extend(settings.fields["flags"].split())

    res = subprocess.run(cmd, cwd=path, capture_output=True)
    if len(res.stderr):
        # if the test should fail, make it pass.
        if settings.fields["fails"]:
            return True, None
        return False, res.stderr
        return False, res.stderr

    if settings.fields["fails"] and not len(res.stderr):
        return False, None

    # If it compiles, run it.
    res = subprocess.run([f"{out_dir}/test"], capture_output=True)
    if os.path.exists(path + "/test.result"):
        with open(path + "/test.result", "rb") as f:
            should_be = f.read()

        if should_be != res.stdout:
            print("\nOutput does not match, should be:")
            print("\033[92m" + str(should_be, "utf8") + "\033[0m")
            print("And is:")
            print("\033[91m" + str(res.stdout, "utf8") + "\033[0m")
            return False, None

        return True, None

    return True, None


from concurrent.futures import ThreadPoolExecutor, as_completed

def run_test_with_unique_binary(test_name: str, out_dir: str) -> tuple[str, bool, Union[bytes, None]]:
    """Run a single test with a unique binary name."""
    binary_name = os.path.join(out_dir, f"test_{test_name.replace('.', '_')}")
    success, stderr = run_test(test_name, binary_name)
    return test_name, success, stderr

def main():
    tests = collect_tests()
    passed = 0

    out_dir = os.path.abspath("./test/__out__")
    if not os.path.exists(out_dir):
        os.makedirs(out_dir, exist_ok=True)

    try:
        for i, test in enumerate(tests):
            print(f"[{i + 1}/{len(tests)}] {test}", end="", flush=True)
            success, stderr = run_test(test, out_dir)
            if success:
                passed += 1
                print("\033[2K\r", end="")
            else:
                print(f"\033[2K\r[{i + 1}/{len(tests)}] \033[91m{test}\033[0m")
                if stderr:
                    print(f"  {str(stderr, 'utf8').strip()}")
    except KeyboardInterrupt:
        print("\nTests interrupted.")

    percent = (passed / len(tests)) * 100 if tests else 0
    if len(tests) == passed:
        print("\033[92m", end="")
    else:
        print("\033[91m", end="")

    print(f"Passed {passed}/{len(tests)} ({percent:.2f}%) tests\033[0m")

    if os.path.exists(out_dir):
        shutil.rmtree(out_dir)


main()
