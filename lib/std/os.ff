/**
 * Never use c calls directly.
 * Some of them working only in types.
 * Use type.func() instead.
 */

__builtin_decl("__c_exit", null, i32)
__builtin_decl("__c_execute", i32, &str)
__builtin_decl("__c_getenv", &str, &str)
__builtin_decl("__c_getcwd", &str)
__builtin_decl("__c_chmod", i32, &str, i32)
__builtin_decl("__c_mkdir", i32, &str)
__builtin_decl("__c_touch", i32, &str)
__builtin_decl("__c_rename", i32, &str, &str)
__builtin_decl("__c_isfile", bool, &str)
__builtin_decl("__c_isdir", bool, &str)
__builtin_decl("__c_islink", bool, &str)
__builtin_decl("__c_isabs", bool, &str)
__builtin_decl("__c_abspath", &str, &str)
__builtin_decl("__c_basename", &str, &str)
__builtin_decl("__c_dirname", &str, &str)
__builtin_decl("__c_expanduser", &str, &str)

/* os.ff
   Copyright (c) 2023 mini-rose */

type os {
	/* Cause normal process termination */

	exit: fn (self: &os, status: i32) -> null {
		__c_exit(status)
	}

	/* Execute a shell command */

	execute: fn (self: &os, command: &str) -> null {
		__c_execute(command)
	}

	execute: fn (self: &os, command: str) -> null {
		__c_execute(&command)
	}

	/* Get an environment variable */

	getenv: fn (self: &os, name: &str) -> &str {
		ret __c_getenv(name)
	}

	getenv: fn (self: &os, name: str) -> &str {
		ret __c_getenv(&name)
	}

	/* Get current working directory */

	getcwd: fn (self: &os) -> &str {
		ret __c_getcwd()
	}

	/* Change file mode bits */

	chmod: fn (self: &os, path: &str, mode: i32) -> i32 {
		ret __c_chmod(path, mode)
	}

	chmod: fn (self: &os, path: str, mode: i32) -> i32 {
		ret __c_chmod(&path, mode)
	}

	/* Make directory */

	mkdir: fn (self: &os, path: &str) -> i32 {
		ret __c_mkdir(path)
	}

	mkdir: fn (self: &os, path: str) -> i32 {
		ret __c_mkdir(&path)
	}

	/* Create file */

	touch: fn (self: &os, path: &str) -> i32 {
		ret __c_touch(path)
	}

	touch: fn (self: &os, path: str) -> i32 {
		ret __c_touch(&path)
	}

	/* Rename file */

	rename: fn (self: &os, old: &str, new: &str) -> i32 {
		ret __c_rename(old, new)
	}

	rename: fn (self: &os, old: str, new: str) -> i32 {
		ret __c_rename(&old, &new)
	}
}

type path {
	/* Return true if the entry is a file */

	isfile: fn (self: &path, path: &str) -> bool {
		ret __c_isfile(path)
	}

	isfile: fn (self: &path, path: str) -> bool {
		ret __c_isfile(&path)
	}

	/* Return true if the entry is a directory */

	isdir: fn (self: &path, path: &str) -> bool {
		ret __c_isdir(path)
	}

	isdir: fn (self: &path, path: str) -> bool {
		ret __c_isdir(&path)
	}

	/* Test whether a path is a symbolic link */

	islink: fn (self: &path, path: &str) -> bool {
		ret __c_islink(path)
	}

	islink: fn (self: &path, path: str) -> bool {
		ret __c_islink(&path)
	}

	/* Test whether a path is absolute */

	isabs: fn (self: &path, path: &str) -> bool {
		ret __c_isabs(path)
	}

	isabs: fn (self: &path, path: str) -> bool {
		ret __c_isabs(&path)
	}

	/* Returns an absolute path */

	abs: fn (self: &path, path: &str) -> &str {
		ret __c_abspath(path)
	}

	abs: fn (self: &path, path: str) -> &str {
		ret __c_abspath(&path)
	}

	/* Returns the final component of a pathname */

	basename: fn (self: &path, path: &str) -> &str {
		ret __c_basename(path)
	}

	basename: fn (self: &path, path: str) -> &str {
		ret __c_basename(&path)
	}

	/* Returns the directory component of a pathname */

	dirname: fn (self: &path, path: &str) -> &str {
		ret __c_dirname(path)
	}

	dirname: fn (self: &path, path: str) -> &str {
		ret __c_dirname(&path)
	}

	/* Expand ~ and ~user constructions.
	   If user or $HOME is unknown, do nothing. */

	expanduser: fn (self: &path, path: &str) -> &str {
		ret __c_expanduser(path)
	}

	expanduser: fn (self: &path, path: str) -> &str {
		ret __c_expanduser(&path)
	}
}
