/* io.ff - standard input/output
   Copyright (c) 2023 mini-rose */

type file_t {
	fp: &i8
	path: str
	is_open: bool
}

/**
 * Open a file_t.
 *
 * @param path: path to the file_t
 * @param mode: either "w" for write or "r" for read
 */
fn open(path: &str, mode: &str) -> file_t {
	f: file_t

	__builtin_decl("_open", &i8, &str, &str)
	f.fp = _open(path, mode)
	f.is_open = false
	f.path = *path

	ret f
}

fn open(path: str, mode: str) -> file_t {
	ret open(&path, &mode)
}

/**
 * Close a file_t.
 *
 * @param self: the file_t to close
 */
fn close(self: &file_t) {
	__builtin_decl("_close", null, &i8)
	_close(self.fp)
}

/**
 * Write a string into the file_t.
 *
 * @param self: file_t to write to
 * @param buf: string to write
 */
fn write(self: &file_t, buf: str) -> null {
	__builtin_decl("_write", null, &i8, &i8, i64)
	_write(self.fp, buf.ptr, buf.len)
}

/**
 * Write a string into a stream, which is marked as a file_t descriptor.
 *
 * @param stream: 1 for stdout, 2 for stderr
 * @param buf: string to write
 */
fn write_stream(stream: i32, buf: str) -> null {
	__builtin_decl("_write_stream", null, i32, &i8, i64)
	_write_stream(stream, buf.ptr, buf.len)
}

fn copy(self: &file_t, other: &file_t) -> null {
	self.fp = other.fp
	self.is_open = other.is_open
}

fn drop(self: &file_t) -> null {
	print('something')
	drop(&self.path)
	// TODO: close the file_t if open
}
